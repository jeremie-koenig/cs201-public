
<style type="text/css">
body {
	max-width: 100ex;
	margin: 1ex auto;
	background-image: url("graphe-clair.png");
	background-repeat: no-repeat;
	background-position: top right;
	background-attachment: fixed;
}
h1 {
	text-align: center;
}
h2 {
	background: #ddd;
	padding: .2ex;
	border-bottom: 1px solid #000;
	margin-top: 2em;
}
pre {
	background: #ddd;
	border: 1px solid #000;
	padding: 1px;
	margin-left: 10ex;
	width: 75ex;
	display: inline-table;
}
</style>


# Scheme style guide for CPSC 201


## Formatting

Because the syntax of Scheme is so uniform,
it is very important
that you organize your code on the page
in a way which makes its structure evident.
Most Scheme programmers employ the rules below.
If you adopt them,
you will never need to scan your code for matching parentheses;
instead, you will recognize the nesting
and content of an expression by the form of the code.

Note that DrRacket helpfully provides an automatic indentation feature:
if you select a block of code and hit the *Tab* key,
the horizontal alignment of each line in the block
will be adjusted to match the nesting of your code.


### Avoid long lines

Long lines in Scheme programs are usually very hard to decipher.
Consider even the simple procedure below:

    (define filter (lambda (pred? lst)
      (cond
        ((null? lst) '())
        ((pred? (car lst)) (cons (car lst) (filter pred? (cdr lst))))
        (else (filter pred? (cdr lst))))))

The second `cond` clause is hard to read, because
your eyes and brain need to figure out where
the condition ends and result expression begins,
and even then
the boundaries of the arguments to `cons`
are not entirely obvious.

In general,
you will want to break lines
immediately after you close one or more parentheses:

    (+ (* 2 3)
       (/ 17 5))

Notice how the closing parenthesis in the product closes the line as well.
This is a good rule of thumb to avoid too complex forms on a line
which would be difficult to read.
Reformatting `filter` above using this rule
gives us the more readable:

    (define filter
      (lambda (pred? lst)
        (cond
          ((null? lst)
           '())
          ((pred? (car lst))
           (cons (car lst)
                 (filter pred? (cdr lst))))
          (else
           (filter pred? (cdr lst))))))


### Parens tend to feel lonely

Don't put closing (or opening) parens on a line of their own. They get
lonely easily. Seriously, it's superfluous information and takes up
lines for nothing. Therefore, the following code is good Scheme style:

    (define (factorial n)
      (if (zero? n)
          1
          (* n (factorial (- n 1)))))

Notice the closing parens at the end. A seasoned schemer won't see
those, though - the expression ends there, the next one begins at
column zero, so they know that everything is closed there.


### Indent subexpressions equally

Basic indentation in Scheme is to indent subexpressions equally. This
is easiest seen in example:

    (list (foo)
          (bar)
          (baz))

As you can see, the expressions `(foo)`, `(bar)` and `(baz)` are all lined
up under each other. They're all on the same syntactic level - all are
arguments to `list` - so they should be lined up under each other.

There are exceptions,
such as `define` as shown above,
or `let`.
They get the body argument indented two spaces from
the definition:

    (let ((pi 3.14)
          (r 120))
      (* pi r r))

In general, DrRacket's automatic indentation does the right thing.


### Break for one - break for all

If you put subexpressions onto multiple lines,
put every subexpression on a single line.

For example, you can write

    (+ 1 foo bar baz)

but if one of those expressions gets more complicated, you may want it
on a line of its own. If so, put all of the subexpressions on lines
of their own:

    (+ 1
       (foo 3.5 a)
       bar
       baz)

If an argument list is broken, a seasoned schemer will expect to find
every argument on a line of its own, so putting more then one on any
of the lines will likely cause the extra argument to be missed.


## Other best practices

Consider this perfectly indented,
perhaps technically correct piece of code:

    (define helper5
      (lambda (x)
        (cond
          ((null? x)
           'error)
          ((null? (cdr x))
           (length (car x)))
          ((> (length (cadr x))
              (length (car x)))
           (helper5 (cons (car x)
                          (cddr x))))
          (else
           (helper5 (cdr x))))))

Because the formatting rules above were followed to the letter,
with a little bit of training,
you will have no trouble figuring out where the subexpressions begin and end,
or which procedure is applied to which arguments.
Still,
even an experienced Scheme programmer
will be unable at first glance
to understand what the procedure above does.

The guidelines below should help you
make sure your code is as clear as possible.


### Choose variable and procedure names carefully

Choosing descriptive names for your variables and procedures
is much more important - and much harder -
than you might suspect at first.

The reason it is important
becomes apparent when when you try to read the code of
`helper5` above.
The name of something is the first,
immediately available piece of information
about what it is and how it behaves.
Hence,
the following procedure is somewhat easier to read
than the previous one,
even though it is identical
as far as the Scheme interpreter is concerned:

    ; Length of the shortest element of a list of lists
    (define shortest-length
      (lambda (lists)
        (cond
          ((null? lists)
           'error)
          ((null? (cdr lists))
           (length (car lists)))
          ((> (length (cadr lists))
              (length (car lists)))
           (shortest-length (cons (car lists)
                                  (cddr lists))))
          (else
           (shortest-length (cdr lists))))))

In fact,
the whole point of defining a procedure is *abstraction*:
we create a black box,
which can then be used as a building block in a more complex system,
with no concern about its inner workings.
From the name of a procedure and the associated comment,
one should be able to predict how the procedure will behave,
without having to study the details of its body.

This is why naming procedures is hard:
you need to reduce a potentially very complicated behavior
into a few words at most.
On the other hand, thinking of a good name
can help you think about
what it is that your procedure should be doing exactly.
And if you have a hard time coming up with an appropriate name,
then perhaps the outline of the black box
you're trying to create
is more complicated than it needs to be?


### Keep your procedures short

Shorter procedures are easier to get right,
read, reason about and debug.
Compare the above procedure with:

    ; Length of the shortest element in a list of lists
    (define shortest-length
      (lambda (moves)
        (smallest-element (lengths-of moves))))

    ; Find the smallest element in a list of numbers
    (define smallest-element
      (lambda (lst)
        (cond
          ((null? lst)
           'error)
          ((null? (cdr lst))
           (car lst))
          (else
           (minimum (car lst)
                    (smallest-element (cdr lst)))))))

    ; Choose the smaller one of two numbers
    (define minimum
      (lambda (x y)
        (if (< x y)
            x
            y)))

    ; Given a list of lists, build a list of their lengths
    (define lengths-of
      (lambda (lists)
        (cond
          ((null? lists)
           '())
          (else
           (cons (length (car lists))
                 (lengths-of (cdr lists)))))))


### Avoid duplicating code and computations

*[FIXME: perhaps it is not ideal to be mixing the two.
How would you go about it?]*

Consider this procedure:

    (define all-short-moves
      (lambda (sum state)
        (keep-moves-of-length (shortest-length (all-moves sum state))
                              (all-moves sum states))))

Notice that `(all-moves sum states)` appears twice.
This means that Scheme will have to compute the exact same thing twice.
This code can be made more efficient
by using `let` to bind the result of this computation
to a local variable:

    (define all-short-moves
      (lambda (sum state)
        (let ((moves (all-moves sum state)))
          (keep-moves-of-length (shortest-length moves)
                                moves))))

More generally,
code duplication is best avoided for several reasons.
If you write the same thing several times,
you're more likely to make a mistake.
If you have to modify it later on,
you might forget about some of the copies.
Whenever you find yourself typing the same thing several times,
it is generally a good indication that
you should be writing an auxiliary procedure.


### Use higher-order procedures

Sometimes it is not entirely obvious how to
package some redundant code into its own procedure.
Consider the following:

    (define keep-moves-of-length
      (lambda (len moves)
        (cond
          ((null? moves)
           '())
          ((= len (length (car moves)))
           (cons (car moves)
                 (keep-moves-of-length len (cdr moves))))
          (else
           (keep-moves-of-length len (cdr moves))))))

    (define keep-possible-moves
      (lambda (sum moves)
        (cond
          ((null? moves)
           '())
          ((= (sum-of (car moves))
              sum)
           (cons (car moves)
                 (keep-possible-moves sum (cdr moves))))
          (else
           (keep-possible-moves sum (cdr moves))))))

Clearly these two procedures have much code in common:
both are meant to filter a list
in order to keep only those elements which
satifsy a certain property
(such as, being of length `len`,
or adding up to `sum`).
The only difference between them
is the code used for testing
which elements qualify.
However, it may not be entierly obvious
how to factorize the common code
into an auxiliary procedure.

Luckily, Scheme procedures are values like any other,
and this can be used to inject some varying code
into a common template as a parameter.
In fact, in this case the common template is exactly the `filter`
procedure which we saw earlier!
For reference we had:

    (define filter
      (lambda (pred? list)
        (cond
          ((null? list)
           '())
          ((pred? (car list))
           (cons (car list)
                 (filter pred? (cdr list))))
          (else
           (filter pred? (cdr list))))))

Then `keep-moves-of-length` and `keep-possible-moves`
can be rewritten as:

    (define keep-moves-of-length
      (lambda (len moves)
        (filter (lambda (m)
                  (= len (length m)))
                moves)))

    (define keep-possible-moves
      (lambda (sum moves)
        (filter (lambda (m)
                  (= (sum-of m)
                     sum))
                moves)))

Procedures which take other procedures as arguments,
or which return procedures as a result,
are called *higher order procedures*,
and they usually correspond to frequently-occuring
patterns of code.
In fact, one such pattern was also present
in the `lengths-of` procedure that we saw earlier:

    ; Given a list of lists, build a list of their lengths
    (define lengths-of
      (lambda (lists)
        (cond
          ((null? lists)
           '())
          (else
           (cons (length (car lists))
                 (lengths-of (cdr lists)))))))

The `lengths-of` procedure
evaluates to a list
consisting of the results
of applying the `length` function
to each element in an existing list.
But we know that this pattern is captured by
the `map` procedure,
hence `lengths-of` can be written as:

    ; Given a list of lists, build a list of their lengths
    (define lengths-of
      (lambda (lists)
        (map length lists)))


## Closing remarks

You may have noticed that in `filter` above,
the subexpression `(filter pred? (cdr list))`
appears twice.
We could have used `let` to factor it out,
however in this particular case,
it would have significantly complicated the code,
defeating the purpose.
Furthermore,
this would break
[tail call optimization](http://en.wikipedia.org/wiki/Tail_call).
The point is:
all of these rules are guidelines.
If you choose to break one, do so.
But be aware that you are breaking one,
and make sure that you have a good reason.

Another way to avoid duplicating code
is to use Scheme's built-in procedures
when one is available that suits a given purpose.
Hence,
in the above,
we could have used `min`
instead of writing `minimum` by hand.
Even better,
since `min` can accept any number of arguments,
we could have used `(apply min lst)`
instead of writing a `smallest-element` procedure.
The variant of Scheme used in CS201,
and the set of built-in procedures,
are defined in the document called
[R5RS](http://www.schemers.org/Documents/Standards/R5RS/HTML/).


## Acknowledgements

This document is distributed under the
[Creative Commons Attribution-ShareAlike 2.0 license](http://creativecommons.org/licenses/by-sa/2.0/).
It is derived from the
[style guide on schemewiki.org](http://community.schemewiki.org/?scheme-style)
(specifically,
[this](http://community.schemewiki.org/?p=scheme-style&c=hv&t=1289999268)
version),
and draws inspiration from
[this excellent document from Dartmouth](http://web.archive.org/web/20020809131500/www.cs.dartmouth.edu/~cs18/F2002/handouts/scheme-tips.html)
as well.

