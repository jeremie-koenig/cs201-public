# Scheme style guide for CPSC 201


## Formatting

Because the syntax of Scheme is so uniform,
it is very important
that you organize your code on the page
in a way which makes its structure evident.
Most Scheme programmers employ the rules below.
If you adopt them,
you will never need to scan your code for matching parentheses;
instead, you will recognize the nesting
and content of an expression by the form of the code.

Note that DrRacket helpfully provides an automatic indentation feature:
if you select a block of code and hit the *Tab* key,
the horizontal alignment of each line in the block
will be adjusted to match the nesting of your code.

All of these rules are guidelines.
If you choose to break one, do so.
But be aware that you are breaking one,
and make sure that you have a good reason.


### Avoid long lines

Long lines in Scheme programs are usually very hard to decipher.
Consider even the simple procedure below:

    (define filter (lambda (pred? lst)
      (cond
        ((null? lst) '())
        ((pred? (car lst)) (cons (car lst) (filter pred? (cdr lst))))
        (else (filter pred? (cdr lst))))))

The second `cond` clause is hard to read, because
your eyes and brain need to figure out where
the condition ends and result expression begins,
and even then
the boundaries of the arguments to `cons`
are not entierly obvious.

In general,
you will want to break lines
immediately after you close one or more parentheses:

    (+ (* 2 3)
       (/ 17 5))

Notice how the closing parenthesis in the product closes the line as well.
This is a good rule of thumb to avoid too complex forms on a line
which would be difficult to read.
Reformatting `filter` above using this rule
gives us the more readable:

    (define filter
      (lambda (pred? lst)
        (cond
          ((null? lst)
           '())
          ((pred? (car lst))
           (cons (car lst)
                 (filter pred? (cdr lst))))
          (else
           (filter pred? (cdr lst))))))


### Indent subexpressions equally

Basic indentation in Scheme is to indent subexpressions equally. This
is easiest seen in example:

    (list (foo)
          (bar)
          (baz))

As you can see, the expressions `(foo)`, `(bar)` and `(baz)` are all lined
up under each other. They're all on the same syntactic level - all are
arguments to `list` - so they should be lined up under each other.

There are exceptions,
such as `define` as shown above,
or `let`.
They get the body argument indented two spaces from
the definition:

    (let ((pi 3.14)
          (r 120))
      (* pi r r))

In general, DrRacket's automatic indentation does the right thing.


### Break for one - break for all

If you put subexpressions onto multiple lines,
put every subexpression on a single line.

For example, you can write

    (+ 1 foo bar baz)

but if one of those expressions gets more complicated, you may want it
on a line of its own. If so, put all of the subexpressions on lines
of their own:

    (+ 1
       (foo 3.5 a)
       bar
       baz)

If an argument list is broken, a seasoned schemer will expect to find
every argument on a line of its own, so putting more then one on any
of the lines will likely cause the extra argument to be missed.


### Parens tend to feel lonely

Don't put closing (or opening) parens on a line of their own. They get
lonely easily. Seriously, it's superfluous information and takes up
lines for nothing. Therefore, the following code is good Scheme style:

    (define (fac n)
      (if (zero? n)
          1
          (* n (fac (- n 1)))))

Notice the closing parens at the end. A seasoned schemer won't see
those, though - the expression ends there, the next one begins at
column zero, so they know that everything is closed there.


## Other best practices

Consider this perfectly indented,
perhaps technically correct piece of code:

    (define helper5
      (lambda (x)
        (cond
          ((null? x)
           'error)
          ((null? (cdr x))
           (length (car x)))
          ((> (length (cadr x))
              (length (car x)))
           (helper5 (cons (car x)
                          (cddr x))))
          (else
           (helper5 (cdr x))))))

Because the formatting rules above were followed to the letter,
with a little bit of training,
you will have no trouble figuring out where the subexpressions begin and end,
or which procedure is applied to which arguments.
Still,
even an experienced Scheme programmer
will be unable at first glance
to understand what the procedure above does.

The guidelines below should help you
make sure your code is as clear as possible.


### Choose variable and procedure names carefully

Choosing descriptive names for your variables and procedures
is much more important - and much harder -
than you might suspect at first.

The reason it is important
should be obvious when you try to read the code of
`helper5` above:
the name of something is the first,
immediately available piece of information
about what that thing is an how it behaves.
Hence,
the following procedure will be easier to read,
even though it is more or less identical to the previous one:

    ; Length of the shortest element of a list of lists
    (define shortest-length
      (lambda (lists)
        (cond
          ((null? lists)
           'error)
          ((null? (cdr lists))
           (length (car lists)))
          ((> (length (cadr lists))
              (length (car lists)))
           (shortest-length (cons (car lists)
                                  (cddr lists))))
          (else
           (shortest-length (cdr lists))))))

In fact,
the whole point of defining a procedure is *abstraction*:
we create a black box
which can be use as a component in more complex systems
with no concern about its inner workings.
From the name of a procedure and the associated comment,
one should be able to predict how the procedure will behave,
from the point of view of an outside observer.

This is why naming procedures is hard:
you need to reduce a potentially very complicated behavior
into a few words at most.
On the other hand, thinking of a good name
can help you think about
what it is that your procedure should be doing exactly.
And if you have a hard time coming up with an appropriate name,
then perhaps the outline of the black box
you're trying to create
is more complicated than it needs to be?


### Keep your procedures short

Shorter procedures are easier to get right,
read, reason about and debug.
Compare the above procedure with:

    ; Length of the shortest element in a list of lists
    (define shortest-length
      (lambda (moves)
        (smallest-element (lengths-of moves))))

    ; Find the smallest element in a list of numbers
    (define smallest-element
      (lambda (lst)
        (cond
          ((null? lst)
           'error)
          ((null? (cdr lst))
           (car lst))
          (else
           (minimum (car lst)
                    (smallest-element (cdr lst)))))))

    ; Choose the smaller one of two numbers
    (define minimum
      (lambda (x y)
        (if (< x y)
            x
            y)))

    ; Given a list of lists, build a list of their lengths
    (define lengths-of
      (lambda (lists)
        (cond
          ((null? lists)
           '())
          (else
           (cons (length (car lists))
                 (lengths-of (cdr lists)))))))


### Avoid duplicating code and computations

Consider this procedure:

    (define all-short-moves
      (lambda (sum state)
        (keep-moves-of-length (shortest-length (all-moves sum state))
                              (all-moves sum states))))

Notice that `(all-moves sum states)` appears twice.
This means that Scheme will have to compute the exact same thing twice.
This code can be made more efficient
by using `let` to bind the result of this computation
to a local variable:

    (define all-short-move
      (lambda (sum state)
        (let ((moves (all-moves sum state)))
          (keep-moves-of-length (shortest-length moves)
                                moves))))

More generally,
code duplication is best avoided for several reasons.
If you write the same thing several times,
you're more likely to make a mistake.
If you have to modify it later on,
you might forget about some of the copies.
Whenever you find yourself typing the same thing several times,
it is generally a good indication that
you should be writing an auxiliary procedure.

Sometimes it is not entirely obvious how to do that.
Consider the following procedures:

    (define keep-moves-of-length
      (lambda (len moves)
        (cond
          ((null? moves)
           '())
          ((= len (length (car moves)))
           (cons (car moves)
                 (keep-moves-of-length len (cdr moves))))
          (else
           (keep-moves-of-length len (cdr moves))))))

    (define keep-possible-moves
      (lambda (sum moves)
        (cond
          ((null? moves)
           '())
          ((= (sum-of (car moves))
              sum)
           (cons (car moves)
                 (keep-possible-moves sum (cdr moves))))
          (else
           (keep-possible-moves sum (cdr moves))))))

Clearly they have much code in common:
both are meant to filter a list
in order to keep only those elements which
satifsy a certain property
(such as, being of length `len`,
or adding up to `sum`).
The only difference between them
is the code used for testing
which elements qualify.
However,
it may not be entierly obvious how to cut it out
into an auxiliary procedure.

But Scheme procedures are values like any other,
and this can be used to inject the varying code
into a common template as a parameter.
The resulting procedure
is traditionally called `filter` and it goes like this:

    (define filter
      (lambda (pred? list)
        (cond
          ((null? list)
           '())
          ((pred? (car list))
           (cons (car list)
                 (filter pred? (cdr list))))
          (else
           (filter pred? (cdr list))))))

Then `keep-moves-of-length` and `keep-possible-moves`
can be rewritten as:

    (define keep-moves-of-length
      (lambda (len moves)
        (filter (lambda (m)
                  (= len (length m)))
                moves)))

    (define keep-possible-moves
      (lambda (sum moves)
        (filter (lambda (m)
                  (= (sum-of m)
                     sum))
                moves)))


## Acknowledgements

This document is distributed under the
[Creative Commons Attribution-ShareAlike 2.0 license](http://creativecommons.org/licenses/by-sa/2.0/).
It is derived from the
[style guide on schemewiki.org](http://community.schemewiki.org/?scheme-style)
(specifically,
[this](http://community.schemewiki.org/?p=scheme-style&c=hv&t=1289999268)
version),
and draws inspiration from
[this document](http://web.archive.org/web/20020809131500/www.cs.dartmouth.edu/~cs18/F2002/handouts/scheme-tips.html)
as well.

